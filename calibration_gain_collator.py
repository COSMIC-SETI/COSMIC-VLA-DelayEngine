import pandas as pd
import numpy as np
import itertools
import argparse
import os
import redis
import time
import json
from delaycalibration import DelayCalibrationWriter
from cosmic.fengines import ant_remotefeng_map
from cosmic.redis_actions import redis_obj, redis_hget_keyvalue, redis_hget_keyvalues, redis_publish_dict_to_hash

class CalibrationGainCollector():
    def __init__(self, redis_obj, fixed_csv, hash_timeout=20, re_arm_time = 30, dry_run = False, nof_streams = 4, nof_tunings = 2, nof_pols = 2, nof_channels = 1024):
        self.redis_obj = redis_obj
        self.fixed_csv = fixed_csv
        self.hash_timeout = hash_timeout
        self.re_arm_time = re_arm_time
        self.dry_run = dry_run
        self.nof_streams = nof_streams
        self.nof_channels = nof_channels
        self.nof_tunings = nof_tunings
        self.nof_pols = nof_pols
        self.ant_feng_map = ant_remotefeng_map.get_antennaFengineDict(self.redis_obj)
        self.pubsub = self.redis_obj.pubsub(ignore_subscribe_messages=True)
        try:
            self.pubsub.subscribe("gpu_calibrationphases")
        except redis.RedisError:
            raise redis.RedisError("""Unable to subscribe to gpu_calibrationphases channel to listen for 
            changes to GPU_calibrationPhases.""")
    
    def get_tuningidx_and_start_freq(self, message_key):
        key_split = message_key.split(',')
        tuning = key_split[-1]
        tuning_index = self.basebands.index(tuning)
        start_freq = float(key_split[0])*1e6

        return tuning_index, start_freq

    def populate_phase_cal_map(self, ant_to_phase_dict, tuning_idx):
        """
        This function is called with a single phase payload generated by the GPU.
        This payload will contain a mapping of antenna names to phase dictionaries which 
        in itself contains the frequencies and per-polarisation phases.
        The tuning index is passed separately.

        This function extracts phases and frequencies from the payload and concatenates them
        into the correct spaces respectively.

        Assumptions: The frequency field in the phase dictionaries is common across antenna.

        Args:
            ant_to_phase_dict : Dictionary map of {ant: {freqs: [xx], pol0_phases: [xx], pol1_phases: [xx]}}

        """

        for ant, phase_dict in ant_to_phase_dict.items():
            freqs = phase_dict['freq_array']
            phase_0 = phase_dict['pol0_phases']
            phase_1 = phase_dict['pol1_phases']
            
            #Concatenate all the phases from the GPU nodes into their correct stream
            self.phase_cal_map[ant+f"_{tuning_idx}"][0] += phase_0
            self.phase_cal_map[ant+f"_{tuning_idx}"][1] += phase_1         

            print("Received phases for tuning: ",tuning_idx, "\n and antenna: ",ant)
        #assume all frequency arrays in the phase dicts are equal but check that we are dealing with the other tuning:
        if not any(f in self.collected_frequencies for f in freqs):
            self.collected_frequencies += freqs

    def collect_phases_for_hash_timeout(self, time_to_wait_until):
        while time.time() <= time_to_wait_until:
            #Listen for messages on subscribed channels
            message = self.pubsub.get_message(timeout=0.1)
            if message and "message" == message["type"]:
                #Initialise a phase calibration array for four streams of zeros:
                try:
                    hash_key = str(message.get('data'))
                except:
                    print("cannot fetch message")
                payload = redis_hget_keyvalue(self.redis_obj, "GPU_calibrationPhases", hash_key)
                tune_idx, _ = self.get_tuningidx_and_start_freq(hash_key)
                self.populate_phase_cal_map(payload, tune_idx)
        return

    def calc_residual_delays_and_phases(self):
        delay_residual_map = {}
        phase_residual_map = {}

        for ant_tune, phase_matrix in self.phase_cal_map.items():
            #Only the phases we have collected... not the ones left to zero
            phase_matrix = np.array(phase_matrix)
            self.collected_frequencies = np.array(self.collected_frequencies)
            phases_unwrapped = np.unwrap(phase_matrix[:,:],axis=1)
            residual_delays = np.zeros(self.nof_pols)
            residual_phases = np.zeros((self.nof_pols,self.collected_frequencies.size))
            for pol in range(self.nof_pols):
                if phases_unwrapped[pol,:].size == 0:
                    print(f"No phases received for antenna_tuning {ant_tune}, pol {pol}")
                    residual_delays[pol] = 0.0
                    residual_phases[pol,:] = np.zeros(self.collected_frequencies.size)
                else:
                    print(f"Calculating residual phases and delays for antenna_tuning {ant_tune}, pol {pol}")
                    phase_slope, _ = np.polyfit(self.collected_frequencies, phases_unwrapped[pol,:], 1)
                    residual = phases_unwrapped[pol,:] - (phase_slope * self.collected_frequencies)
                    residual_delays[pol]=phase_slope / (2*np.pi)
                    residual_phases[pol,:] = residual % (2*np.pi)

            delay_residual_map[ant_tune] = residual_delays
            phase_residual_map[ant_tune] = residual_phases
        return delay_residual_map, phase_residual_map

    def correctly_place_residual_phases_and_delays(self, residual_phases, residual_delays):
        """
        By investigating the placement of `self.collected_frequencies` inside of `self.full_observation_channel_frequencies_hz`,
        a map of how to place the calculated `residual_phases` inside an array of `self.nof_channels` per stream per antenna
        may be generated.

        Args:
            residual_phases: a dictionary mapping of {ant_tuning: phases[nof_pols, nof_collected_frequencies]}
            residual_delays: a dictionary mapping of {ant_tuning: delays[nof_pols, 1]}

        Modifies:
            full_residual_phase_map : a dictionary mapping of {ant: [nof_streams, nof_frequencies]} 
            full_residual_delay_map : a dictionary mapping of {ant: [nof_streams, 1]} 
        """
        #Find where to place the phases in phase_cal_map
        frequency_indices = self.full_observation_channel_frequencies_hz.searchsorted(self.collected_frequencies)
        for ant_tuning, phase_matrix in residual_phases.items():
            ant, tuning = ant_tuning.split("_")
            tuning = int(tuning)
            #populate phases
            self.full_residual_phase_map[ant][tuning*2, frequency_indices] = phase_matrix[0,:] 
            self.full_residual_phase_map[ant][(tuning*2) + 1, frequency_indices] = phase_matrix[1,:]
            #populate delays
            self.full_residual_delay_map[ant][tuning*2] = residual_delays[ant_tuning][0]
            self.full_residual_delay_map[ant][(tuning*2) + 1] = residual_delays[ant_tuning][1]


    def start(self):
        while True:
            #Listen for messages on subscribed channels
            message = self.pubsub.get_message(timeout=0.1)
            if message and "message" == message["type"]:
                #Initialise a phase calibration array for four streams of zeros:
                try:
                    hash_key = str(message.get('data'))
                except:
                    print("cannot fetch message")
                payload = redis_hget_keyvalue(self.redis_obj, "GPU_calibrationPhases", hash_key)
                filestem = redis_hget_keyvalue(self.redis_obj, "GPU_calibrationPhases",'filestem')
                metadata = redis_hget_keyvalues(self.redis_obj, "META")
                # self.basebands = metadata.get('baseband')
                self.basebands = ['AC_8BIT','BD_8BIT']
                tune_idx, _ = self.get_tuningidx_and_start_freq(hash_key)
                self.collected_frequencies = []
                self.ants = list(payload.keys())

                #create the phase_cal map of antnames -> phase values of shape (nof_streams, nof_channels)
                self.phase_cal_map ={}
                self.full_residual_phase_map={}
                self.full_residual_delay_map={}
                zeros_phases = np.zeros((self.nof_streams,self.nof_channels))
                zeros_delays = np.zeros((self.nof_streams,1))
                for ant in self.ants:
                    self.full_residual_phase_map[ant] = zeros_phases.copy() 
                    self.full_residual_delay_map[ant] = zeros_delays.copy()
                for ant,tuning_idx in itertools.product(self.ants, range(2)):
                    self.phase_cal_map[ant+f"_{tuning_idx}"] = [[],[]]

                fcent_mhz = metadata['fcents'][tune_idx]
                print("Observation center frequency: ",fcent_mhz,"MHz")
                fcent_hz = fcent_mhz * 1e6
                #spoofing fcents
                fcent_hz = np.median(payload[self.ants[0]]['freq_array'])
                print("Observation center frequency: ",fcent_hz,"Hz")
                channel_width_hz = payload[self.ants[0]]['freq_array'][1] - payload[self.ants[0]]['freq_array'][0]
                print("Channel width: ",channel_width_hz,"Hz")
                start_observation_channel_frequencies_hz = fcent_hz - (self.nof_channels//2)*channel_width_hz
                stop_observation_channel_frequencies_hz = fcent_hz + (self.nof_channels//2)*channel_width_hz

                self.full_observation_channel_frequencies_hz = np.arange(start_observation_channel_frequencies_hz, stop_observation_channel_frequencies_hz, channel_width_hz)
                print("Full observation channel frequncies: ",self.full_observation_channel_frequencies_hz,"\n of size: ",self.full_observation_channel_frequencies_hz.size)
                
                self.populate_phase_cal_map(payload, tune_idx)

                #Listen for new messages for the hash timeout period
                time_to_wait_until = time.time() + self.hash_timeout
                self.collect_phases_for_hash_timeout(time_to_wait_until) 

                #calculate residual delays/phases, save them and publish them
                delay_residual_map, phase_residual_map = self.calc_residual_delays_and_phases()

                #Create residual phase array in correct frequency placement and mangle residual delays into correct placement
                self.correctly_place_residual_phases_and_delays(phase_residual_map, delay_residual_map)

                #For json dumping:
                t_delay_dict = {}
                t_phase_dict = {}
                for ant, val in self.full_residual_phase_map.items():
                    t_delay_dict[ant] = self.full_residual_delay_map[ant].tolist() 
                    t_phase_dict[ant] = val.tolist() 

                delay_filename = os.path.join("/home/cosmic/dev/logs/calibration_logs/",f"calibrationdelayresiduals_{filestem}.json")
                print("Wrote out calculated residual delays to: ",delay_filename)

                with open(delay_filename, 'w') as f:
                    json.dump(t_delay_dict, f)
                redis_publish_dict_to_hash(self.redis_obj, "META_residualDelays",t_delay_dict)


                phase_filename = os.path.join("/home/cosmic/dev/logs/calibration_logs/",f"calibrationphaseresiduals_{filestem}.json")
                print("Wrote out calculated residual phases to: ",phase_filename)

                with open(phase_filename, 'w') as f:
                    json.dump(t_phase_dict, f)
                redis_publish_dict_to_hash(self.redis_obj, "META_residualPhases",t_phase_dict)
                
                if not self.dry_run:
                    #load phases to F-Engines
                    for ant, feng in self.ant_feng_map.items():
                        for stream in range(self.nof_streams):
                            #One of the ones we computed phases for:
                            if ant in self.full_residual_phase_map:
                                # try:
                                wrap_phases = (self.full_residual_phase_map[ant][stream,:]  + np.pi) % (2 * np.pi) - np.pi
                                feng.phaserotate.set_phase_cal(
                                    stream,   
                                    wrap_phases.tolist()
                                )
                                # except:
                                #     print("Could not write out phase calibrations to the antenna: ",ant)
                            #Zero the rest:
                            else:
                                # try:
                                feng.phaserotate.set_phase_cal(
                                    stream,
                                    np.zeros(1024).tolist()
                                )
                                # except:
                                    # print("Could not write out zeros to the antenna: ",ant)

                    # update fixed_delays
                    fixed_delays = pd.read_csv(os.path.abspath(self.fixed_csv), names = ["IF0","IF1","IF2","IF3"],
                                header=None, skiprows=1)
                    fixed_delays = fixed_delays.to_dict()
                   
                    updated_fixed_delays = {}
                    for i, tune in enumerate(list(fixed_delays.keys())):
                        sub_updated_fixed_delays = {}
                        for ant, delay in fixed_delays[tune].items():
                            if ant in self.full_residual_delay_map:
                                sub_updated_fixed_delays[ant] = delay + float(-1e9 * self.full_residual_delay_map[ant][i,:])
                            else:
                                sub_updated_fixed_delays[ant] = delay
                        updated_fixed_delays[tune] = sub_updated_fixed_delays

                    #bit of logic here to remove the previous filestem from the name.
                    modified_fixed_delays_path = "/home/cosmic/dev/logs/calibration_logs/"+os.path.basename(self.fixed_csv).split('.')[0].split('%')[0]+"%"+filestem+".csv"                    
                    print("Wrote out modified fixed delays to: ",modified_fixed_delays_path)
                    df = pd.DataFrame.from_dict(updated_fixed_delays)
                    df.to_csv(modified_fixed_delays_path)

                    delay_calibration = DelayCalibrationWriter(self.redis_obj, modified_fixed_delays_path)
                    delay_calibration.run()

                    self.fixed_csv = modified_fixed_delays_path

                time.sleep(self.re_arm_time)
            

if __name__ == "__main__":
    parser = argparse.ArgumentParser(
    description=("""Listen for updates to GPU hashes containing calibration phases
    and generate residual delays and load calibration phases to the F-Engines.""")
    )
    parser.add_argument("--hash-timeout", type=float,default=20, required=False, help="""How long to wait for calibration 
    postprocessing to complete and update phases.""")
    parser.add_argument("--dry-run", action="store_true", help="""If run as a dry run, delay residuals and phases are 
    calcualted and written to redis/file but not loaded to the F-Engines nor applied to the existing fixed-delays.""")
    parser.add_argument("--re-arm-time", type=float, default=30, required=False, help="""After collecting phases
    from GPU nodes and performing necessary actions, the service will sleep for this duration until re-arming""")
    parser.add_argument("-f","--fixed-delay-to-update", type=str, required=True, help="""
    csv file path to latest fixed delays that must be modified by the residual delays calculated in this script.""")
    args = parser.parse_args()

    calibrationGainCollector = CalibrationGainCollector(redis_obj, fixed_csv = args.fixed_delay_to_update, 
                                hash_timeout = args.hash_timeout, re_arm_time = args.re_arm_time)
    calibrationGainCollector.start()