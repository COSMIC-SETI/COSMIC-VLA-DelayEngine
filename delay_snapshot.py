import pandas as pd
import numpy as np
import argparse
from cosmic.redis_actions import redis_obj, redis_hget_keyvalues
from delaymodel import DelayModel
from astropy.coordinates import SkyCoord
import matplotlib.pyplot as plt
import os

def gen_delay_vectors(model_delays, calib_delays, time_range, use_calib=False):
    """
    From the above arguments, generate a matrix of dimension = (ant, delay, time)
    
    Args:
        model_delays(dict) : model delays generated by DelayModel object
        calib_delays(ns)   : calibration delays antenna -> delays per IF 
        time_range(s)      : the time range in seconds over which to compute delays
        use_calib          : include the calibration delays in the calculation
    """

    ant_to_delay_dict = {}
    ant_to_delay_rate_dict = {}

    if use_calib:
        for ant, calib_delay in calib_delays.items():
            if ant in model_delays:
                time = time_range - model_delays[ant]["time_value"]
                t_arr = np.zeros((4,len(time_range)))
                for i, c_delay in enumerate(calib_delay.values()): 
                    t_arr[i, :] = (model_delays[ant]["delay_raterate_nsps2"] * (time**2) +
                                        (model_delays[ant]["delay_rate_nsps"] * time) +
                                        (model_delays[ant]["delay_ns"] + c_delay))

                ant_to_delay_dict[ant] = t_arr
                ant_to_delay_rate_dict[ant] = ((model_delays[ant]["delay_raterate_nsps2"] * time) +
                                                (model_delays[ant]["delay_rate_nsps"])) 
    else:
        for ant, delay in model_delays.items():
            time = time_range - delay["time_value"]
            ant_to_delay_dict[ant] = ((delay["delay_raterate_nsps2"] * (time**2)) +
                                    (delay["delay_rate_nsps"] * time) +
                                    (delay["delay_ns"]))
            ant_to_delay_rate_dict[ant] = ((delay["delay_raterate_nsps2"] * time) +
                                                (delay["delay_rate_nsps"])) 

    return ant_to_delay_dict, ant_to_delay_rate_dict

def plot_delays_and_rates(ant_to_delay_dict, ant_to_delay_rate_dict, time_range, output_dir):
    """
    Over the time range provided, generate and save a plot the delays per IF and delay rates for every antenna.

    Args:
        ant_to_delay_dict        : Dictionary mapping antenna names to delays of dimension (nof_if, time)
        ant_to_delay_rate_dict   : Dictionary mapping antenna names to delay rates vector
        time_range               : A numpy vector of the time range the delays were calculated for.
    """
    nof_ifs, _ = np.array([(ant_to_delay_dict[list(ant_to_delay_dict.keys())[0]])]).shape
    for ant, delays in ant_to_delay_dict.items():
        fig, ax = plt.subplots(nof_ifs, 1, figsize = (10,10))
        fig.suptitle(f"Antenna {ant} delays")
        if nof_ifs > 1:
            for i in range(nof_ifs):
                ax[i].plot(time_range, delays[i,:], label=f"IF_{i}")
        else:
            ax.plot(time_range, delays[:], label=f"all_IF's")
        fig.legend()
        fig.text(0.5, 0.04, 'time (s)', ha='center')
        fig.text(0.04, 0.5, 'delay (ns)', va='center', rotation='vertical')
        fig.savefig(os.path.join(output_dir, f"{ant}_delay_plot.png"))
        plt.close()

    for ant, delays in ant_to_delay_rate_dict.items():
        fig,ax = plt.subplots(1, 1, figsize = (6,6))
        fig.suptitle(f"Antenna {ant} delay rates")
        ax.plot(time_range, delays, label="all_IF's")
        fig.legend()
        fig.text(0.5, 0.04, 'time (s)', ha='center')
        fig.text(0.04, 0.5, 'delay rate (ns/s)', va='center', rotation='vertical')
        fig.savefig(os.path.join(output_dir, f"{ant}_delay_rate_plot.png"))
        plt.close()

if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        description=("Generate a delay snapshot for a given ra/dec and timeslice.")
    )
    parser.add_argument("--ra", type=float, default=0.0, help="right ascension in degrees as a floating point")
    parser.add_argument("--dec", type=float, default=0.0, help="declination in degrees as a floating point")
    parser.add_argument("--start_time", type=float, default=0.0, help="start time in seconds from start of epoch")
    parser.add_argument("--stop_time", type=float, default=1, help="stop time in seconds from start of epoch")
    parser.add_argument("--ntime", type=float, required=False, default=100, help="number of delay values to compute over stop_time - start_time")
    parser.add_argument("--plot", type=bool, required=False, default=True, help="""Generate plots per antenna of the delays per IF over the specified time span
                                                                if True, otherwise write delay and delay rates to CSV files.""")
    parser.add_argument("--add_calibration_delays", type=bool, required=False, default=False,
                                                                help="Include the telescope calibration delays in the output.")
    parser.add_argument("--out_dir", type=str, required=False, default="./delay_outputs")
    args = parser.parse_args()

    time_range = np.arange(args.start_time, args.stop_time, args.time_granularity)

    calib_delays = redis_hget_keyvalues(redis_obj, "META_calibrationDelays")

    delay_model = DelayModel(redis_obj)
    delay_model.source = SkyCoord(args.ra, args.dec, unit='deg')
    model_delays = delay_model.calculate_delay(publish = False)

    ant_to_delay_dict, ant_to_delay_rate_dict = gen_delay_vectors(model_delays, calib_delays, time_range, use_calib=args.add_calibration_delays)

    if args.out_dir:
        if os.path.isdir(args.out_dir):
            pass
        else:
            os.makedirs(args.out_dir)

    if args.plot:
        plot_delays_and_rates(ant_to_delay_dict, ant_to_delay_rate_dict, time_range, args.out_dir)
    else:
        pd.DataFrame.from_dict(ant_to_delay_dict).to_csv(f"antenna_delays_ra{args.ra}_dec{args.dec}.csv")
        pd.DataFrame.from_dict(ant_to_delay_rate_dict).to_csv(f"antenna_delay_rates_ra{args.ra}_dec{args.dec}.csv")
    





